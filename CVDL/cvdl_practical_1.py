# -*- coding: utf-8 -*-
"""CVDL_Practical_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13nP2YaHpw7xKjU5tmlEKURBdCVBd1BvQ
"""

import cv2
import os
from google.colab.patches import cv2_imshow
import numpy as np

image_path = 'lenaimg.png'

if os.path.exists(image_path):
    # Read the image
    original_image = cv2.imread(image_path)
    if original_image is not None:

        print("Original Image:")
        cv2_imshow(original_image)

    else:
        print(f"Failed to read image at {image_path}")

else:
    print(f"File not found: {image_path}")

"""-------------------------------------------------------**apply color filter**---------------------------------------------------


"""

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

print("Grayscale Image:")
grayscale = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
cv2_imshow(grayscale)

print("Grayscale to RGB:")
gray_to_rgb = cv2.cvtColor(grayscale, cv2.COLOR_GRAY2BGR)
cv2_imshow(gray_to_rgb)

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

print("HSV Image:")
cv2_imshow(hsv)

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()
b, g, r = cv2.split(image)

print("Blue Channel:")
cv2_imshow(b)

print("Green Channel:")
cv2_imshow(g)

print("Red Channel:")
cv2_imshow(r)

"""-------------------------------------------------------**apply blur filter**---------------------------------------------------"""

#Normal blur uses a simple average of all pixels within a defined kernel (window),
print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

print("Normal Blur:")
blurred_image = cv2.blur(image, (5, 5))
cv2_imshow(blurred_image)

#Gaussian blur uses a weighted average, with the center pixel having the highest weight and weights decreasing with distance
print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

print("Gaussian Blur:")
blurred_image = cv2.GaussianBlur(image, (5, 5), 0)
cv2_imshow(blurred_image)

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

# Apply minimum filter using erosion
# Erosion takes the minimum value in a 3x3 kernel, useful for noise reduction
print("Minimum Filter:")
min_filtered = cv2.erode(image, kernel=np.ones((3, 3), np.uint8))
cv2_imshow(min_filtered)

# Apply maximum filter using dilation
# Dilation takes the maximum value in a 3x3 kernel, enhances bright regions
print("Maximum Filter:")
max_filtered = cv2.dilate(image, kernel=np.ones((3, 3), np.uint8))
cv2_imshow(max_filtered)

# Apply median filter
# Replaces each pixel with the median of its neighbors in a 3x3 kernel
# Great for removing salt-and-pepper noise
print("Median Filter:")
median_filtered = cv2.medianBlur(image, 3)
cv2_imshow(median_filtered)

"""-------------------------------------------------------**apply canny filter**---------------------------------------------------"""

img = original_image.copy()
canny_original = cv2.Canny(img, 125, 175)  # threshold1, threshold2

blurred = cv2.GaussianBlur(img, (5,5), 0)  # (kernel size), sigma = 0
canny_blurred = cv2.Canny(blurred, 125, 175)

print("Original Image:")
cv2_imshow(original_image)

print("Canny on Original Image:")
cv2_imshow(canny_original)

print("Blurred Image:")
cv2_imshow(blurred)

print("Canny on Blurred Image:")
cv2_imshow(canny_blurred)

"""-------------------------------------------------------**apply crop filter**---------------------------------------------------"""

img = original_image.copy()
print("Original Image:")
cv2_imshow(img)

print('Crop the image: rows from 0 to 100, columns from 200 to 400:')
cropped = img[0:1000, 100:900]
cv2_imshow(cropped)

"""-------------------------------------------------------**apply resize filter**---------------------------------------------------"""

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()
resized = cv2.resize(image, (int(image.shape[1] / 2), int(image.shape[0] / 2)))

print("Resized Image:")
cv2_imshow(resized)

print("Original Image:")
cv2_imshow(original_image)

img = original_image.copy()

print("Resize an image by skipping every alternate row and column:")
resized_image_1 = np.empty((img.shape[0] // 2, img.shape[1] // 2, 3), dtype=np.uint8)

for i in range(0, img.shape[0], 2):
    for j in range(0, img.shape[1], 2):
        resized_image_1[i // 2, j // 2] = img[i, j]

cv2_imshow(resized_image_1)

print("Original Image:")
cv2_imshow(original_image)

img = original_image.copy()
print("Resizing with averaging over 2×2 pixel blocks:")
resized_image_2 = np.empty((img.shape[0] // 2, img.shape[1] // 2, 3), dtype=np.uint8)

for i in range(0, img.shape[0] - 1, 2):
    for j in range(0, img.shape[1] - 1, 2):
        block_avg = (
            img[i, j].astype(np.float32) +
            img[i+1, j].astype(np.float32) +
            img[i, j+1].astype(np.float32) +
            img[i+1, j+1].astype(np.float32)
        ) / 4
        resized_image_2[i // 2, j // 2] = block_avg.astype(np.uint8)

cv2_imshow(resized_image_2)

"""-------------------------------------------------------**apply rescale filter**---------------------------------------------------"""

def rescale_image(frame, scale=0.75):
    # Calculate new width and height based on scale
    width = int(frame.shape[1] * scale)
    height = int(frame.shape[0] * scale)
    dimensions = (width, height)

    # Resize and return the image
    return cv2.resize(frame, dimensions)

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

scaled_image = rescale_image(image, 0.5)
print("Scaled Image:")
cv2_imshow(scaled_image)

"""-------------------------------------------------------**apply shrinking filter**---------------------------------------------------"""

print("Original Image:")
cv2_imshow(original_image)

# Create a copy to work on
image = original_image.copy()

# Shrinking by resizing to 300% of original width and height
print("Shrunken Image:")
shrunken = cv2.resize(image, (int(image.shape[1] * 3.0), int(image.shape[0] * 3.0)))
cv2_imshow(shrunken)

"""-------------------------------------------------------**apply translation filter**---------------------------------------------------

"""

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

def translation(img, x, y):

    # [1, 0, x] → shift in x-direction
    # [0, 1, y] → shift in y-direction
    transMat = np.float32([[1, 0, x], [0, 1, y]])

    # Set the output image dimensions (same as original)
    dimensions = (img.shape[1], img.shape[0])

    # Apply the affine transformation using warpAffine
    return cv2.warpAffine(img, transMat, dimensions)

# Apply translation: move 100 pixels right and 100 pixels up
# +x = right, -x = left | +y = down, -y = up
print("Translated Image (Right 100px, Up 100px):")
translated = translation(image, 100, -100)
cv2_imshow(translated)

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

# Flip horizontally (left ↔ right)
print("Flipped Image (Horizontally):")
flipped_horizontal = cv2.flip(image, 1)
cv2_imshow(flipped_horizontal)

# Flip vertically (top ↕ bottom)
print("Flipped Image (Vertically):")
flipped_vertical = cv2.flip(image, 0)
cv2_imshow(flipped_vertical)

# Flip both horizontally and vertically (180° rotation)
print("Flipped Image (Both Horizontally and Vertically):")
flipped_both = cv2.flip(image, -1)
cv2_imshow(flipped_both)

"""-------------------------------------------------------**apply rotation filter**---------------------------------------------------

"""

print("Original Image:")
cv2_imshow(original_image)

img = original_image.copy()
(height, width) = img.shape[:2]
center = (width // 2, height // 2)

angles = [45, 90, 135, 180, 225, 270]  # You already did 45

for angle in angles:
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(img, rotation_matrix, (width, height))
    print(f"Rotated Image ({angle} degrees):")
    cv2_imshow(rotated)

"""-------------------------------------------------------**apply shearing filter**---------------------------------------------------

"""

print("Original Image:")
cv2_imshow(original_image)

image = original_image.copy()

rows, cols = image.shape[:2]

# Shearing in x-direction by 0.5 and y-direction by 0.2
shear_matrix = np.float32([[1, 0.5, 0], [0.2, 1, 0]])

sheared = cv2.warpAffine(image, shear_matrix, (int(cols * 1.5), int(rows * 1.5)))

# Display the sheared image
print("Sheared Image (X: 0.5, Y: 0.2):")
cv2_imshow(sheared)

"""-------------------------------------------------------**apply rgb to grayscale filter**---------------------------------------------------

"""

print("Original Image:")
cv2_imshow(original_image)

image_copy = original_image.copy()
print("Proper grayscale image (single channel):")
gray_scale_2 = np.empty((image_copy.shape[0], image_copy.shape[1]), dtype=np.uint8)

for i in range(image_copy.shape[0]):
    for j in range(image_copy.shape[1]):
        b = image_copy[i, j, 0] / 3
        g = image_copy[i, j, 1] / 3
        r = image_copy[i, j, 2] / 3
        gray = b + g + r
        gray_scale_2[i, j] = np.uint8(gray)

cv2_imshow(gray_scale_2)

"""-------------------------------------------------------**apply min, max, median filter**---------------------------------------------------"""

img = original_image.copy()
max_image = np.empty((img.shape[0]-1, img.shape[1]-1, 3), dtype=np.uint8)

for i in range(1, img.shape[0]-1):
    for j in range(1, img.shape[1]-1):
        max_image[i-1, j-1] = np.max(img[i-1:i+2, j-1:j+2], axis=(0, 1))

print("Max Image:")
cv2_imshow(max_image)

img = original_image.copy()
min_image = np.empty((img.shape[0]-1, img.shape[1]-1, 3), dtype=np.uint8)

for i in range(1, img.shape[0]-1):
    for j in range(1, img.shape[1]-1):
        min_image[i-1, j-1] = np.min(img[i-1:i+2, j-1:j+2], axis=(0, 1))

print("Min Image:")
cv2_imshow(min_image)

img = original_image.copy()
median_image = np.empty((img.shape[0]-1, img.shape[1]-1, 3), dtype=np.uint8)

for i in range(1, img.shape[0]-1):
    for j in range(1, img.shape[1]-1):
        median_image[i-1, j-1] = np.median(img[i-1:i+2, j-1:j+2], axis=(0, 1))

print("median Image:")
cv2_imshow(median_image)

